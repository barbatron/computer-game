// Generated by CoffeeScript 1.6.3
(function() {
  var Bit, BitStack, CallStack, Cursor, CursorController, EOP, Frame, FuBar, Head, If, Ifs, Jump, Move, Op, Pop, Program, Push, Seek, Swap, Tape, bootstrap, j, root,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  root = this || window;

  j = $;

  root.toHex = function(d) {
    var hex, padding;
    hex = Number(d).toString(16);
    padding = (typeof padding === "undefined" || padding === null ? padding = 2 : padding);
    while (hex.length < padding) {
      hex = "0" + hex;
    }
    return "#" + hex;
  };

  root.megaPromise = function(promArr) {
    var countDown, megaDefer, prom, _i, _len;
    megaDefer = w.defer();
    countDown = promArr.length;
    for (_i = 0, _len = promArr.length; _i < _len; _i++) {
      prom = promArr[_i];
      prom.then(function() {
        countDown--;
        if (countDown <= 0) {
          return megaDefer.resolve();
        }
      });
    }
    return megaDefer.promise;
  };

  root.dummyPromise = function(ctx, func) {
    return function() {
      var d;
      d = w.defer();
      func.call(ctx);
      d.resolve;
      return d.promise;
    };
  };

  Bit = (function() {
    function Bit(addr, value) {
      this.addr = addr;
      this.value = value != null ? value : false;
      this.hexAddr = toHex(this.addr);
      this.bit = j("<div class='bit " + this.value + "' index=" + this.addr + ">" + this.hexAddr + "</div>");
    }

    Bit.prototype.elem = function() {
      return j("[index=" + this.addr + "]");
    };

    Bit.prototype.swap = function() {
      return this.set(!this.value);
    };

    Bit.prototype.set = function(value) {
      this.elem().removeClass(this.value + '');
      this.value = value;
      return this.elem().addClass(this.value + '');
    };

    return Bit;

  })();

  Tape = (function() {
    function Tape(bits) {
      this.bits = bits;
    }

    Tape.prototype.snapshot = function() {
      var data, v, _i, _len, _ref;
      data = {};
      _ref = this.bits.slice(0, 16);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        data[v.addr] = v.value;
      }
      return data;
    };

    Tape.prototype.restore = function(data) {
      var k, v, _results;
      _results = [];
      for (k in data) {
        v = data[k];
        _results.push(this.bits[k].set(v));
      }
      return _results;
    };

    return Tape;

  })();

  Cursor = (function() {
    function Cursor(at, host) {
      this.at = at;
      this.host = host;
      this.move = __bind(this.move, this);
      if (this.at == null) {
        this.at = this.host.getFirstAddr();
      }
      this.draw();
    }

    Cursor.prototype.draw = function() {
      j(".head").each(function() {
        return j(this).removeClass("head");
      });
      return this.myBit().addClass("head");
    };

    Cursor.prototype.myBit = function() {
      return j("[index=" + this.at + "]");
    };

    Cursor.prototype.move = function(d) {
      return this._move(d);
    };

    Cursor.prototype._move = function(d) {
      console.log("move", this.at);
      this.at = this.host.getIndex(this.at, d);
      return this.draw();
    };

    return Cursor;

  })();

  Head = (function(_super) {
    __extends(Head, _super);

    function Head(at, host) {
      this.at = at;
      this.host = host;
      this.read = __bind(this.read, this);
      this.move = __bind(this.move, this);
      Head.__super__.constructor.call(this, this.at, this.host);
    }

    Head.prototype.move = function(d, record) {
      var op;
      if (record) {
        op = new Move(d);
        root.program().addOp(op);
        return op.exec();
      } else {
        return this._move(d);
      }
    };

    Head.prototype.seek = function(at) {
      this.at = at;
      return this.draw();
    };

    Head.prototype.test = function() {
      return (this.myBit().attr("is")) === "1";
    };

    Head.prototype.read = function() {
      return this._read();
    };

    Head.prototype._read = function() {
      return root.tape.bits[this.at].value;
    };

    Head.prototype.write = function(value) {
      root.tape.bits[this.at].set(value);
      return this.draw();
    };

    Head.prototype.commit = function() {
      var editOp;
      editOp = root.program().latestOp();
      if (root.activeCursor === root.head && (editOp != null ? editOp.type : void 0) === "Move") {
        root.program().removeOp(editOp);
        return root.program().addOp(new Seek(root.head.at));
      }
    };

    return Head;

  })(Cursor);

  Op = (function() {
    function Op(type, param) {
      this.type = type;
      this.param = param;
      this.param = ko.observable(this.param);
      this.display = "";
      this.displayAddr = ko.observable(this.addr || 0);
    }

    Op.prototype.exec = function(cs) {
      if (cs == null) {
        cs = null;
      }
      this._exec();
      if (cs != null) {
        return this.next(cs);
      }
    };

    Op.prototype._exec = function() {};

    Op.prototype.displayAddr = function() {
      return '';
    };

    Op.prototype.merge = function(op, actions) {
      return actions.push(op);
    };

    Op.prototype.next = function(cs) {
      return cs.peek().incrementPos();
    };

    return Op;

  })();

  Swap = (function(_super) {
    __extends(Swap, _super);

    function Swap() {
      Swap.__super__.constructor.call(this, "Swap");
    }

    Swap.prototype._exec = function() {
      return root.tape.bits[root.head.at].swap();
    };

    Swap.prototype.merge = function(op, actions) {
      return actions.pop();
    };

    return Swap;

  })(Op);

  Move = (function(_super) {
    __extends(Move, _super);

    function Move(delta) {
      var _this = this;
      Move.__super__.constructor.call(this, "Move", delta);
      this.display = ko.computed(function() {
        return _this.param();
      });
    }

    Move.prototype._exec = function() {
      console.log("move", this);
      return root.head.move(this.param());
    };

    Move.prototype.merge = function(op) {
      return this.param(this.param() + op.param());
    };

    return Move;

  })(Op);

  EOP = (function(_super) {
    __extends(EOP, _super);

    function EOP() {
      EOP.__super__.constructor.call(this, "EOP");
    }

    EOP.prototype.next = function(cs) {
      if (cs.frames().length > 1) {
        return cs.pop();
      } else {
        return cs.peek().reset();
      }
    };

    return EOP;

  })(Op);

  Seek = (function(_super) {
    __extends(Seek, _super);

    function Seek(target) {
      var _this = this;
      Seek.__super__.constructor.call(this, "Seek", target);
      this.display = ko.computed(function() {
        return toHex(_this.param());
      });
    }

    Seek.prototype._exec = function() {
      return root.head.seek(this.param());
    };

    Seek.prototype.merge = function(op, actions) {
      return this.param(op.param());
    };

    return Seek;

  })(Op);

  Jump = (function(_super) {
    __extends(Jump, _super);

    function Jump(target) {
      var _this = this;
      Jump.__super__.constructor.call(this, "Jump", target);
      this.display = ko.computed(function() {
        return toHex(_this.param());
      });
    }

    Jump.prototype._exec = function() {};

    Jump.prototype.next = function(cs) {
      return cs.switchProgram(root.fu.getProg(this.param()));
    };

    /*  d = w.defer()
      current = root.program()
      root.program root.fu.getProg(@param())
      root.program().exec().then ->
        root.program(current)
        d.resolve()
      d.promise
    */


    return Jump;

  })(Op);

  If = (function(_super) {
    __extends(If, _super);

    function If(condition) {
      var _this = this;
      this.condition = condition != null ? condition : true;
      If.__super__.constructor.call(this, "If", this.condition);
      this.display = ko.computed(function() {
        return _this.param().toString();
      });
    }

    If.prototype.next = function(cs) {
      cs.peek().incrementPos();
      if (root.head.read() !== this.param()) {
        return cs.peek().incrementPos();
      }
    };

    If.prototype.merge = function() {
      return this.param(!this.param());
    };

    return If;

  })(Op);

  Ifs = (function(_super) {
    __extends(Ifs, _super);

    function Ifs(condition) {
      var _this = this;
      this.condition = condition != null ? condition : true;
      Ifs.__super__.constructor.call(this, "Ifs", this.condition);
      this.display = ko.computed(function() {
        return _this.param().toString();
      });
    }

    Ifs.prototype.next = function(cs) {
      cs.peek().incrementPos();
      if (root.bitStack.pop() !== this.param()) {
        return cs.peek().incrementPos();
      }
    };

    Ifs.prototype.merge = function() {
      return this.param(!this.param());
    };

    return Ifs;

  })(Op);

  Push = (function(_super) {
    __extends(Push, _super);

    function Push() {
      Push.__super__.constructor.call(this, "Push");
    }

    Push.prototype._exec = function() {
      var b, bit;
      b = root.head.read();
      bit = {
        addr: ko.observable(root.head.at),
        value: ko.observable(b)
      };
      return root.bitStack.push(bit);
    };

    return Push;

  })(Op);

  Pop = (function(_super) {
    __extends(Pop, _super);

    function Pop() {
      Pop.__super__.constructor.call(this, "Pop");
    }

    Pop.prototype._exec = function() {
      var bit;
      bit = root.bitStack.pop();
      if (bit != null) {
        return root.head.write(bit.value());
      }
    };

    return Pop;

  })(Op);

  Program = (function() {
    function Program(addr, name, savedOps) {
      var op, _i, _len, _ref,
        _this = this;
      this.addr = addr;
      this.name = name;
      this.savedOps = savedOps;
      this.removeOp = __bind(this.removeOp, this);
      this.rename = __bind(this.rename, this);
      this.addr = ko.observable(this.addr);
      this.writeProtected = ko.observable(false);
      this.displayAddr = ko.computed(function() {
        return toHex(this.addr());
      }, this);
      this.name = ko.observable(this.name ? this.name : "new program");
      this.ops = ko.observableArray();
      _ref = ko.utils.unwrapObservable(this.savedOps || []);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        op = _ref[_i];
        op = root.opFactory(ko.utils.unwrapObservable(op.type), ko.utils.unwrapObservable(op.param));
        this.pushOp(op);
      }
      this.addOp(new EOP());
      this.changed = ko.observable(false).extend({
        notify: 'always'
      });
      this.changed.subscribe(function() {
        if (_this.changed() && (_this.latestOp() != null)) {
          _this.save();
          return root.save();
        }
      });
    }

    Program.prototype.hasAddr = function(addr) {
      var opHasAddr;
      opHasAddr = function(op) {
        return op.addr() === addr;
      };
      return ko.utils.arrayFirst(this.ops(), opHasAddr) != null;
    };

    Program.prototype.rename = function() {
      return this._rename();
    };

    Program.prototype._rename = function() {
      var name;
      name = window.prompt('Enter program name', this.name());
      if (!((name != null) && name.length > 0)) {
        return;
      }
      this.name(name);
      return this.changed(true);
    };

    Program.prototype.save = function() {
      root.fu.addProg(this);
      return this.changed(false);
    };

    Program.prototype.pushOp = function(op) {
      var opaddr, opdaddr;
      opaddr = function() {
        return this.addr() + this.ops.indexOf(op);
      };
      op.addr = ko.computed(opaddr, this);
      opdaddr = function() {
        return toHex(typeof this.addr === "function" ? this.addr() : void 0);
      };
      op.displayAddr = ko.computed(opdaddr, op);
      op.addr.subscribe(function(newAddr) {
        return root.tape.bits[newAddr] = op;
      });
      return this.ops.push(op);
    };

    Program.prototype.addOp = function(op) {
      var actions, eop, latest;
      latest = this.latest();
      if ((latest != null ? latest.type : void 0) === "EOP") {
        eop = this.ops.pop();
        latest = this.latest();
      }
      actions = (function(context) {
        return {
          push: function() {
            return context.pushOp.call(context, op);
          },
          pop: function() {
            return context.ops.pop(op);
          },
          none: function() {}
        };
      })(this);
      if (typeof this.changed === "function") {
        this.changed(true);
      }
      if ((latest != null ? latest.type : void 0) === op.type) {
        latest.merge(op, actions);
      } else {
        actions.push(op);
      }
      if ((eop != null) && (op != null ? op.type : void 0) !== "EOP") {
        return this.pushOp(eop);
      }
    };

    Program.prototype.removeOp = function(op) {
      return this._removeOp(op);
    };

    Program.prototype._removeOp = function(op) {
      return this.ops.remove(op);
    };

    Program.prototype.arr = function() {
      return this.ops();
    };

    Program.prototype.start = function() {
      return this.addr();
    };

    Program.prototype.size = function() {
      return this.arr().length;
    };

    Program.prototype.getAddr = function(op) {
      return this.addr() + "" + this.ops.indexOf(op);
    };

    Program.prototype.getOp = function(addr) {
      return ko.utils.arrayFirst(this.ops(), function(o) {
        return (o != null ? o.addr() : void 0) === addr;
      });
    };

    Program.prototype.latest = function() {
      return this.arr()[this.arr().length - 1];
    };

    Program.prototype.latestOp = function() {
      if (this.arr().length > 1) {
        return this.arr()[this.arr().length - 2];
      } else {
        return null;
      }
    };

    Program.prototype.latestAddr = function() {
      return this.addr() + this.arr().length - 1;
    };

    return Program;

  })();

  CursorController = (function() {
    function CursorController(host) {
      this.host = host;
    }

    CursorController.prototype.getIndex = function(i, d) {
      var newPos;
      newPos = i - this.host.start() + d;
      if (newPos >= 0) {
        return (newPos % this.host.size()) + this.host.start();
      } else {
        return this.host.size() + this.host.start() + newPos;
      }
    };

    return CursorController;

  })();

  FuBar = (function() {
    function FuBar(savedProgs) {
      this.delProgram = __bind(this.delProgram, this);
      var prog, _i, _len, _ref;
      this.progs = ko.observableArray();
      this.progs.equalityComparer = function(a, b) {
        return a.addr() === b.addr();
      };
      _ref = ko.utils.unwrapObservable(savedProgs || []);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        prog = _ref[_i];
        this.addProg(new Program(prog.addr, prog.name, prog.ops));
      }
    }

    FuBar.prototype.nextAddress = function() {
      var maxAddr;
      maxAddr = 0;
      ko.utils.arrayForEach(this.progs(), function(prog) {
        if (prog.addr() > maxAddr) {
          return maxAddr = prog.addr();
        }
      });
      return maxAddr + 0x1000;
    };

    FuBar.prototype.isSaved = function(prog) {
      return this.progs.indexOf(prog) > -1;
    };

    FuBar.prototype.love = function(prog) {
      console.log(prog);
      return prog.writeProtected(true);
    };

    FuBar.prototype.newProgram = function(name) {
      var addr, prog;
      if (name == null) {
        name = null;
      }
      addr = this.nextAddress();
      prog = new Program(addr, name);
      this.addProg(prog);
      return prog;
    };

    FuBar.prototype.getProg = function(addr) {
      return ko.utils.arrayFirst(this.progs(), function(prog) {
        return prog.addr() === addr || prog.hasAddr(addr);
      });
    };

    FuBar.prototype.delProgram = function(prog) {
      return this._delProgram(prog);
    };

    FuBar.prototype._delProgram = function(prog) {
      this.progs.remove(prog);
      return root.save();
    };

    FuBar.prototype.getFirstAddr = function() {
      return this.progs()[0].addr();
    };

    FuBar.prototype.addProg = function(prog) {
      var existing, exists, i;
      exists = this.progs.indexOf(prog) > -1;
      if (exists) {
        existing = this.getProg(prog.addr());
        prog.addr(existing.addr());
        i = this.progs.indexOf(existing);
        this.progs()[i] = prog;
        return;
      }
      return this.progs.unshift(prog);
    };

    FuBar.prototype.getIndex = function(i, d) {
      var arrIndex, newIndex, progAtIndex;
      progAtIndex = ko.utils.arrayFirst(this.progs(), function(prog) {
        return prog.addr() === i;
      });
      arrIndex = this.progs.indexOf(progAtIndex);
      newIndex = new CursorController(this).getIndex(arrIndex, d);
      return this.progs()[newIndex].addr();
    };

    FuBar.prototype.start = function() {
      return 0;
    };

    FuBar.prototype.size = function() {
      return this.progs().length;
    };

    FuBar.prototype.getCursor = function() {
      var c, newProg, useJumpSelection,
        _this = this;
      newProg = new Program(this.nextAddress());
      newProg.name("<create new program>");
      this.addProg(newProg);
      useJumpSelection = function() {
        var addr, eopAddr, firstFrame, newSelected, op, prog;
        addr = root.activeCursor.at;
        prog = _this.getProg(addr);
        newSelected = prog.addr() === newProg.addr();
        if (newSelected) {
          prog.rename();
        } else {
          _this.delProgram(newProg);
        }
        op = new Jump(addr);
        root.program().addOp(op);
        root.callstack.switchProgram(prog);
        if (newSelected) {
          root.program(prog);
        } else {
          firstFrame = root.callstack.peek();
          eopAddr = firstFrame.program.latestAddr();
          while (firstFrame.pos !== eopAddr) {
            root.callstack.step();
          }
          root.callstack.step();
        }
        root.activeCursor.commit = null;
        root.activeCursor = root.head;
        return root.head.draw();
      };
      c = new Cursor(null, root.fu);
      c.commit = useJumpSelection;
      return c;
    };

    return FuBar;

  })();

  Frame = (function() {
    function Frame(addr) {
      var _this = this;
      this.addr = addr;
      this.program = root.fu.getProg(this.addr);
      this.program.ops.subscribe(function(ops) {
        _this.pos = _this.program.latestAddr() - 1;
        return _this.showPos();
      });
      this.saveEntryState();
      this.reset();
    }

    Frame.prototype.saveEntryState = function() {
      return this.runState = root.getSnapshot();
    };

    Frame.prototype.restore = function() {
      root.setSnapshot(this.runState);
      return this.reset();
    };

    Frame.prototype.step = function() {
      var op;
      op = root.tape.bits[this.pos];
      console.log("Executing op " + (toHex(this.pos)) + " (" + op.type + ")");
      return op.exec(root.callstack);
    };

    Frame.prototype.reset = function() {
      this.pos = this.addr;
      return this.showPos();
    };

    Frame.prototype.incrementPos = function(pos) {
      this.pos++;
      return this.showPos();
    };

    Frame.prototype.showPos = function() {
      var _this = this;
      return _.defer(function() {
        var el, level;
        level = root.callstack.indexOf(_this);
        el = j('[level="' + level + '"]');
        console.log(el);
        el.find(".pos").removeClass("pos");
        return el.find("[index=" + _this.pos + "]").addClass("pos");
      });
    };

    return Frame;

  })();

  CallStack = (function() {
    function CallStack(addr) {
      this.switchProgram = __bind(this.switchProgram, this);
      this.frames = ko.observableArray();
      this._push(addr);
    }

    CallStack.prototype.peek = function() {
      return this.frames()[this.frames().length - 1];
    };

    CallStack.prototype._push = function(addr) {
      return this.frames.push(new Frame(addr));
    };

    CallStack.prototype.pop = function(addr) {
      var edit;
      if (this.peek().program === root.program()) {
        edit = true;
      }
      this.frames.pop();
      this.peek().incrementPos();
      if (edit != null) {
        root.program(this.peek().program);
      }
      return this.peek();
    };

    CallStack.prototype.step = function() {
      return this.peek().step();
    };

    CallStack.prototype.isEditing = function(prog) {
      return prog === root.program();
    };

    CallStack.prototype.indexOf = function(frame) {
      return this.frames.indexOf(frame);
    };

    CallStack.prototype.switchProgram = function(prog, clearStack) {
      if (clearStack == null) {
        clearStack = false;
      }
      if (prog == null) {
        prog = root.fu.newProgram();
      }
      if (clearStack) {
        root.program(prog);
        this.frames([]);
      }
      return this._push(prog.addr());
    };

    /*snapshot: () ->
      frames = []
      xferFunction = (f) ->
        framedata = {}
        framedata.program = 
          addr: f.program.addr()
          name: f.program.name()
          ops: ko.toJS(f.program.ops)
        framedata.pos = f.pos # exec pos            
      return ko.util.arrayMap @frames, xferFunction
    restore:
    */


    return CallStack;

  })();

  BitStack = (function() {
    function BitStack() {
      this.items = ko.observableArray();
    }

    BitStack.prototype.push = function(bit) {
      return this.items.unshift(bit);
    };

    BitStack.prototype.pop = function() {
      if (this.items().length > 0) {
        return this.items.shift();
      }
      return null;
    };

    BitStack.prototype.snapshot = function() {
      return ko.toJS(this.items);
    };

    BitStack.prototype.restore = function(data) {
      return this.items(data);
    };

    return BitStack;

  })();

  root.getSnapshot = function() {
    var bitStack, headAt, tape;
    tape = root.tape.snapshot();
    bitStack = root.bitStack.snapshot();
    headAt = root.head.at;
    return {
      tape: tape,
      bitStack: bitStack,
      headAt: headAt
    };
  };

  root.setSnapshot = function(data) {
    root.tape.restore(data.tape);
    root.bitStack.restore(data.bitStack);
    return root.head.seek(data.headAt);
  };

  root.save = function() {
    var time;
    localStorage['fu'] = ko.toJSON(root.fu);
    time = new Date().getTime();
    return localStorage["fu" + time] = ko.toJSON(root.fu);
  };

  root.load = function() {
    var fuStr, fus;
    fuStr = localStorage['fu'];
    if ((fuStr != null) && fuStr.length > 0) {
      fus = JSON.parse(fuStr);
      if ((fus != null ? fus.progs : void 0) != null) {
        root.fu = new FuBar(fus.progs);
        return;
      }
    }
    return root.fu = new FuBar();
  };

  root.selectJumpProg = function() {
    return root.activeCursor = root.fu.getCursor();
  };

  root.keyDown = function(e) {
    var eopAddr, firstFrame, op, prog, _base, _ref;
    console.log(e.which);
    if (e.which === 38) {
      root.activeCursor.move(-1, true);
    }
    if (e.which === 40) {
      root.activeCursor.move(1, true);
    }
    if (e.shiftKey) {
      if (root.activeCursor === root.head) {
        root.selectJumpProg();
      } else {
        if (typeof (_base = root.activeCursor).commit === "function") {
          _base.commit();
        }
      }
    }
    if (e.which === 96 || e.which === 48) {
      console.log('restoring');
      root.callstack.peek().restore();
    }
    if (e.ctrlKey) {
      if (e.which === 82) {
        window.location.reload();
      } else {
        op = new If();
        root.program().addOp(op);
      }
    }
    if (e.which === 9) {
      root.program().save();
      root.save();
      if (root.callstack.frames().length > 1) {
        root.callstack.frames.pop();
        root.program(root.callstack.peek().program);
      } else {
        root.callstack.switchProgram();
      }
    }
    if (e.which === 27) {
      window.location.reload();
    }
    if (e.which === 78) {
      prog = root.fu.newProgram();
      root.callstack.switchProgram(prog, true);
    }
    if (e.which > 48 && e.which < 58) {
      prog = root.fu.progs()[e.which - 49];
      if (prog != null) {
        root.callstack.switchProgram(prog);
      }
    }
    if (e.which === 13) {
      if ((_ref = root.activeCursor) != null) {
        if (typeof _ref.commit === "function") {
          _ref.commit();
        }
      }
    }
    if (e.which === 88) {
      op = new Ifs();
      op.exec();
      root.program().addOp(op);
    }
    if (e.altKey) {
      op = new Swap();
      root.program().addOp(op);
      op.exec();
    }
    if (e.which === 32) {
      root.callstack.step();
    }
    if (e.which === 82) {
      firstFrame = root.callstack.frames()[0];
      eopAddr = firstFrame.program.latestAddr();
      while (root.callstack.frames()[0].pos !== eopAddr) {
        root.callstack.step();
      }
    }
    if (e.which === 8) {
      op = root.program().latestOp();
      if (op != null) {
        root.program().removeOp(op);
      }
    }
    if (e.which === 39) {
      op = new Push();
      op.exec();
      root.program().addOp(op);
    }
    if (e.which === 37) {
      op = new Pop();
      op.exec();
      root.program().addOp(op);
    }
    if (!(e.which === 116 || e.which === 123)) {
      return e.preventDefault();
    }
  };

  bootstrap = function() {
    var a, arr, prog, _i;
    arr = [];
    for (a = _i = 0; _i <= 15; a = ++_i) {
      arr[a] = new Bit(a, false);
      j(".strip.memory").append(arr[a].bit);
    }
    root.tape = new Tape(arr);
    root.fu = new FuBar();
    root.load();
    root.head = new Head(0, new CursorController({
      start: function() {
        return 0;
      },
      size: function() {
        return 16;
      }
    }));
    root.bitStack = new BitStack();
    root.activeCursor = root.head;
    prog = root.fu.newProgram('new program');
    root.program = ko.observable(prog);
    root.callstack = new CallStack(root.program().addr());
    return ko.applyBindings(root, j('body').get(0));
  };

  root.ops = {
    Op: Op,
    Move: Move,
    Seek: Seek,
    Swap: Swap,
    Jump: Jump,
    If: If,
    Ifs: Ifs,
    EOP: EOP,
    Push: Push,
    Pop: Pop
  };

  root.opFactory = function(type, param) {
    return new root.ops[type](param);
  };

  bootstrap();

}).call(this);

/*
//@ sourceMappingURL=script.map
*/
